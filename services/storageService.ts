import { Booking, AccessLog, User, UserRole, AppNotification } from '../types';
import { DEMO_USERS, EXTERNAL_DB_CONFIG } from '../constants';
import { supabase } from './supabaseClient';

const KEYS = {
  USER: 'albrook_current_user',
};

// Utility to simulate network delay for local operations
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// --- BOOKINGS (SUPABASE) ---

const mapRowToBooking = (row: any): Booking => ({
    id: row.id,
    userId: row.user_id,
    userName: row.user_name,
    userRole: row.user_role as UserRole,
    date: row.date,
    hour: row.hour,
    headCount: row.head_count,
    status: row.status as 'CONFIRMED' | 'CANCELLED'
});

export const getBookings = async (): Promise<Booking[]> => {
  try {
      const { data, error } = await supabase
        .from(EXTERNAL_DB_CONFIG.BOOKINGS_TABLE)
        .select('*');
      
      if (error) throw error;
      return data.map(mapRowToBooking);
  } catch (err) {
      console.error("Error fetching bookings:", err);
      return [];
  }
};

export const saveBooking = async (booking: Booking): Promise<void> => {
  const { error } = await supabase
    .from(EXTERNAL_DB_CONFIG.BOOKINGS_TABLE)
    .insert({
        id: booking.id, // Ensure UUID consistency if generated by frontend
        user_id: booking.userId,
        user_name: booking.userName,
        user_role: booking.userRole,
        date: booking.date,
        hour: booking.hour,
        head_count: booking.headCount,
        status: booking.status
    });

  if (error) throw new Error(error.message);
};

export const updateBookingStatus = async (id: string, status: 'CONFIRMED' | 'CANCELLED'): Promise<void> => {
    const { error } = await supabase
        .from(EXTERNAL_DB_CONFIG.BOOKINGS_TABLE)
        .update({ status: status })
        .eq('id', id);

    if (error) throw new Error(error.message);
}

export const deleteBooking = async (id: string): Promise<void> => {
    const { error } = await supabase
        .from(EXTERNAL_DB_CONFIG.BOOKINGS_TABLE)
        .delete()
        .eq('id', id);

    if (error) throw new Error(error.message);
};

// --- LOGS (SUPABASE) ---

const mapRowToLog = (row: any): AccessLog => ({
    id: row.id,
    bookingId: row.booking_id,
    checkInTime: row.check_in_time,
    checkOutTime: row.check_out_time
});

export const getLogs = async (): Promise<AccessLog[]> => {
  try {
      const { data, error } = await supabase
        .from(EXTERNAL_DB_CONFIG.LOGS_TABLE)
        .select('*');

      if (error) throw error;
      return data.map(mapRowToLog);
  } catch (err) {
      console.error("Error fetching logs:", err);
      return [];
  }
};

export const saveLog = async (log: AccessLog): Promise<void> => {
  // Using upsert to handle both insert (new check-in) and update (check-out)
  const { error } = await supabase
    .from(EXTERNAL_DB_CONFIG.LOGS_TABLE)
    .upsert({
        id: log.id,
        booking_id: log.bookingId,
        check_in_time: log.checkInTime,
        check_out_time: log.checkOutTime
    });

  if (error) throw new Error(error.message);
};

// --- USER MANAGEMENT (SUPABASE) ---

// Helper to map Supabase row to User type
const mapRowToUser = (row: any): User => ({
    id: row.id.toString(),
    // MAPPING: DB uses 'fullName', App uses 'name'
    name: row.fullName || row.name || 'Sin Nombre',
    // Login fields
    username: row.username || row.email || 'user', 
    password: row.password || '', 
    // MAPPING: DB uses 'category', App uses 'role'
    role: (row.category as UserRole) || (row.role as UserRole) || UserRole.INDIVIDUAL,
    email: row.email || '',
    phone: row.phone || '',
    status: row.status || 'ACTIVO'
});

export const getAllUsers = async (): Promise<User[]> => {
  try {
      // 1. Fetch from Supabase
      const { data, error } = await supabase
        .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
        .select('*')
        .order('fullName', { ascending: true }); // Order by fullName
      
      if (error) throw error;

      // 2. Map to User objects
      const dbUsers = data.map(mapRowToUser);

      // 3. Merge with DEMO_USERS
      const cleanDemos = DEMO_USERS.filter(d => !dbUsers.find(db => db.username === d.username));
      
      return [...cleanDemos, ...dbUsers];
  } catch (err) {
      console.error("Error cargando usuarios de Supabase:", err);
      return DEMO_USERS;
  }
};

export const registerUser = async (user: User): Promise<void> => {
  if (DEMO_USERS.find(u => u.username === user.username)) {
      throw new Error("No se puede sobreescribir un usuario Demo del sistema.");
  }

  // Insert mapping to specific table columns
  const { error } = await supabase
    .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
    .insert({
        fullName: user.name,      // Map name -> fullName
        category: user.role,      // Map role -> category
        username: user.username,
        password: user.password,
        email: user.email,
        phone: user.phone,
        status: user.status || 'ACTIVO', // Map status
        joinDate: new Date().toISOString() // Fill required text field
    });

  if (error) {
      if (error.code === '23505') throw new Error("El nombre de usuario o teléfono ya existe.");
      throw new Error(error.message);
  }
};

export const updateUser = async (updatedUser: User): Promise<void> => {
  if (DEMO_USERS.find(u => u.id === updatedUser.id)) {
      throw new Error("No se pueden editar los usuarios de demostración locales.");
  }

  // Prepare payload dynamically
  const updatePayload: any = {
    fullName: updatedUser.name,
    category: updatedUser.role,
    username: updatedUser.username,
    email: updatedUser.email,
    phone: updatedUser.phone,
    status: updatedUser.status
  };

  if (updatedUser.password && updatedUser.password.trim().length > 0) {
      updatePayload.password = updatedUser.password;
  }

  const { error } = await supabase
    .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
    .update(updatePayload)
    .eq('id', updatedUser.id);

  if (error) throw new Error(error.message);
};

export const deleteUser = async (userId: string): Promise<void> => {
  if (DEMO_USERS.find(u => u.id === userId)) {
      throw new Error("No se pueden eliminar los usuarios de demostración locales.");
  }

  const { error } = await supabase
    .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
    .delete()
    .eq('id', userId);

  if (error) throw new Error(error.message);
};

export const loginUser = async (username: string): Promise<User | null> => {
  const demoUser = DEMO_USERS.find(u => u.username === username);
  if (demoUser) {
     const user = { ...demoUser, role: demoUser.role as UserRole };
     localStorage.setItem(KEYS.USER, JSON.stringify(user));
     return user;
  }

  try {
      const { data, error } = await supabase
        .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
        .select('*')
        .eq('username', username)
        .single();

      if (error || !data) return null;

      const user = mapRowToUser(data);
      localStorage.setItem(KEYS.USER, JSON.stringify(user));
      return user;
  } catch (err) {
      console.error("Login Error:", err);
      return null;
  }
};

export const getCurrentUser = (): User | null => {
  const data = localStorage.getItem(KEYS.USER);
  return data ? JSON.parse(data) : null;
};

export const logoutUser = () => {
  localStorage.removeItem(KEYS.USER);
};

export interface AccountStatus {
  exists: boolean;
  data?: any;
  message?: string;
}

export const getAccountStatusByPhone = async (phone: string): Promise<AccountStatus> => {
  if (!phone) return { exists: false, message: "No hay teléfono registrado en su perfil." };
  
  try {
    const { data, error } = await supabase
      .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
      .select('*')
      .eq(EXTERNAL_DB_CONFIG.PHONE_COLUMN, phone)
      .limit(1);

    if (error) {
      return { exists: false, message: `Error DB: ${error.message}` };
    }

    if (data && data.length > 0) {
      return { exists: true, data: data[0] };
    } else {
      return { exists: false, message: "No se encontró suscripción activa." };
    }
  } catch (err: any) {
    return { exists: false, message: `Error de conexión.` };
  }
};

// --- NOTIFICATIONS ---

const mapRowToNotification = (row: any): AppNotification => ({
    id: row.id,
    userId: row.user_id,
    title: row.title,
    message: row.message,
    isRead: row.is_read,
    createdAt: row.created_at,
    type: row.type || 'INFO'
});

export const getNotifications = async (userId: string): Promise<AppNotification[]> => {
    try {
        const { data, error } = await supabase
            .from(EXTERNAL_DB_CONFIG.NOTIFICATIONS_TABLE)
            .select('*')
            .eq('user_id', userId)
            .order('created_at', { ascending: false });
        
        if (error) throw error;
        return data.map(mapRowToNotification);
    } catch (err: any) {
        // Log warning only if table is likely missing (code 42P01 in Postgres is undefined_table, but Supabase JS error codes might vary)
        if (err.message && err.message.includes('does not exist')) {
            console.warn(`[Supabase] La tabla '${EXTERNAL_DB_CONFIG.NOTIFICATIONS_TABLE}' no existe. Ejecute el script en db_schema.sql`);
        } else {
             console.error("Error fetching notifications:", err);
        }
        return [];
    }
};

export const markNotificationAsRead = async (notificationId: string): Promise<void> => {
    try {
        await supabase
            .from(EXTERNAL_DB_CONFIG.NOTIFICATIONS_TABLE)
            .update({ is_read: true })
            .eq('id', notificationId);
    } catch (err) {
        console.error("Failed to mark read", err);
    }
};

export const sendNotification = async (recipientId: string, title: string, message: string, type: 'INFO' | 'WARNING' | 'ALERT' = 'INFO'): Promise<void> => {
    try {
        await supabase
            .from(EXTERNAL_DB_CONFIG.NOTIFICATIONS_TABLE)
            .insert({
                user_id: recipientId,
                title,
                message,
                type,
                is_read: false
            });
    } catch (err) {
        console.error("Failed to send notification", err);
        throw err;
    }
};

export const broadcastNotification = async (title: string, message: string, targetRole?: UserRole): Promise<void> => {
    try {
        // 1. Get recipients
        let users = await getAllUsers();
        if (targetRole) {
            users = users.filter(u => u.role === targetRole);
        }

        // 2. Prepare Payload
        const payload = users.map(u => ({
            user_id: u.id,
            title,
            message,
            type: 'INFO',
            is_read: false
        }));

        if (payload.length === 0) return;

        // 3. Bulk Insert
        await supabase
            .from(EXTERNAL_DB_CONFIG.NOTIFICATIONS_TABLE)
            .insert(payload);
            
    } catch (err) {
        console.error("Broadcast failed", err);
        throw err;
    }
};