
import { Booking, AccessLog, User, UserRole, AppNotification, Suggestion } from '../types';
import { DEMO_USERS, EXTERNAL_DB_CONFIG } from '../constants';
import { supabase } from './supabaseClient';

const KEYS = {
  USER: 'albrook_current_user',
};

// CONSTANTS
const POOL_LENGTH_METERS = 50;

// Utility to simulate network delay for local operations
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// --- BOOKINGS (SUPABASE) ---

const mapRowToBooking = (row: any): Booking => ({
    id: row.id,
    userId: row.user_id,
    userName: row.user_name,
    userRole: row.user_role as UserRole,
    date: row.date,
    hour: row.hour,
    headCount: row.head_count,
    status: row.status as 'CONFIRMED' | 'CANCELLED'
});

export const getBookings = async (): Promise<Booking[]> => {
  try {
      const { data, error } = await supabase
        .from(EXTERNAL_DB_CONFIG.BOOKINGS_TABLE)
        .select('*');
      
      if (error) throw error;
      return data.map(mapRowToBooking);
  } catch (err) {
      console.error("Error fetching bookings:", err);
      return [];
  }
};

export const saveBooking = async (booking: Booking): Promise<void> => {
  const { error } = await supabase
    .from(EXTERNAL_DB_CONFIG.BOOKINGS_TABLE)
    .insert({
        id: booking.id, // Ensure UUID consistency if generated by frontend
        user_id: booking.userId,
        user_name: booking.userName,
        user_role: booking.userRole,
        date: booking.date,
        hour: booking.hour,
        head_count: booking.headCount,
        status: booking.status
    });

  if (error) throw new Error(error.message);
};

export const updateBookingStatus = async (id: string, status: 'CONFIRMED' | 'CANCELLED'): Promise<void> => {
    const { error } = await supabase
        .from(EXTERNAL_DB_CONFIG.BOOKINGS_TABLE)
        .update({ status: status })
        .eq('id', id);

    if (error) throw new Error(error.message);
}

export const deleteBooking = async (id: string): Promise<void> => {
    const { error } = await supabase
        .from(EXTERNAL_DB_CONFIG.BOOKINGS_TABLE)
        .delete()
        .eq('id', id);

    if (error) throw new Error(error.message);
};

// --- LOGS (SUPABASE) ---

const mapRowToLog = (row: any): AccessLog => ({
    id: row.id,
    bookingId: row.booking_id,
    checkInTime: row.check_in_time,
    checkOutTime: row.check_out_time,
    laps: row.laps || 0
});

export const getLogs = async (): Promise<AccessLog[]> => {
  try {
      const { data, error } = await supabase
        .from(EXTERNAL_DB_CONFIG.LOGS_TABLE)
        .select('*');

      if (error) throw error;
      return data.map(mapRowToLog);
  } catch (err) {
      console.error("Error fetching logs:", err);
      return [];
  }
};

export const saveLog = async (log: AccessLog): Promise<void> => {
  // Using upsert to handle both insert (new check-in) and update (check-out)
  const payload: any = {
        id: log.id,
        booking_id: log.bookingId,
        check_in_time: log.checkInTime,
        check_out_time: log.checkOutTime
    };
  
  // Only add laps if it is defined, otherwise DB default (0) handles it
  if (log.laps !== undefined) {
      payload.laps = log.laps;
  }

  const { error } = await supabase
    .from(EXTERNAL_DB_CONFIG.LOGS_TABLE)
    .upsert(payload);

  if (error) throw new Error(error.message);
};

// --- RANKING & STATS UTILS ---

export interface RankingItem {
    userId: string;
    userName: string;
    totalLaps: number;
    totalMeters: number;
    totalTimeMinutes: number;
    rank: number;
}

export interface PersonalStats {
    weeklyLaps: number;
    weeklyMeters: number;
    weeklyTimeMinutes: number;
    
    monthlyLaps: number;
    monthlyMeters: number;
    monthlyTimeMinutes: number;
    
    yearlyLaps: number;
    yearlyMeters: number;
    yearlyTimeMinutes: number;
    
    bestDayLaps: number;
    bestDayMeters: number;
    bestDayDate: string;
}

export const getSwimmerStats = async (userId: string): Promise<PersonalStats> => {
    try {
        const [bookings, logs] = await Promise.all([getBookings(), getLogs()]);
        
        // Map logs to bookings to get dates and calc duration
        const userLogs = logs.filter(l => l.laps && l.laps > 0).map(l => {
            const booking = bookings.find(b => b.id === l.bookingId);
            
            // Calculate duration in minutes if both times exist
            let duration = 0;
            if (l.checkInTime && l.checkOutTime) {
                const start = new Date(l.checkInTime).getTime();
                const end = new Date(l.checkOutTime).getTime();
                duration = Math.max(0, Math.round((end - start) / 60000));
            }

            return {
                laps: l.laps || 0,
                meters: (l.laps || 0) * POOL_LENGTH_METERS,
                duration: duration,
                date: booking ? new Date(booking.date) : new Date(0),
                userId: booking?.userId
            };
        }).filter(item => item.userId === userId);

        const now = new Date();
        const startOfWeek = new Date(now);
        startOfWeek.setDate(now.getDate() - now.getDay() + (now.getDay() === 0 ? -6 : 1)); // Monday
        startOfWeek.setHours(0,0,0,0);

        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
        const startOfYear = new Date(now.getFullYear(), 0, 1);

        // Accumulators
        let weeklyLaps = 0; let weeklyMeters = 0; let weeklyTime = 0;
        let monthlyLaps = 0; let monthlyMeters = 0; let monthlyTime = 0;
        let yearlyLaps = 0; let yearlyMeters = 0; let yearlyTime = 0;
        
        // Calculate Totals
        userLogs.forEach(entry => {
            if (entry.date >= startOfWeek) {
                weeklyLaps += entry.laps;
                weeklyMeters += entry.meters;
                weeklyTime += entry.duration;
            }
            if (entry.date >= startOfMonth) {
                monthlyLaps += entry.laps;
                monthlyMeters += entry.meters;
                monthlyTime += entry.duration;
            }
            if (entry.date >= startOfYear) {
                yearlyLaps += entry.laps;
                yearlyMeters += entry.meters;
                yearlyTime += entry.duration;
            }
        });

        // Calculate Best Day
        const lapsByDay: Record<string, number> = {};
        userLogs.forEach(entry => {
            const dateStr = entry.date.toISOString().split('T')[0];
            lapsByDay[dateStr] = (lapsByDay[dateStr] || 0) + entry.laps;
        });

        let bestDayLaps = 0;
        let bestDayDate = '-';

        Object.entries(lapsByDay).forEach(([date, count]) => {
            if (count > bestDayLaps) {
                bestDayLaps = count;
                bestDayDate = date;
            }
        });

        return { 
            weeklyLaps, weeklyMeters, weeklyTimeMinutes: weeklyTime,
            monthlyLaps, monthlyMeters, monthlyTimeMinutes: monthlyTime,
            yearlyLaps, yearlyMeters, yearlyTimeMinutes: yearlyTime,
            bestDayLaps, bestDayMeters: bestDayLaps * POOL_LENGTH_METERS, bestDayDate 
        };

    } catch (e) {
        console.error("Error calculating stats", e);
        return { 
            weeklyLaps: 0, weeklyMeters: 0, weeklyTimeMinutes: 0,
            monthlyLaps: 0, monthlyMeters: 0, monthlyTimeMinutes: 0,
            yearlyLaps: 0, yearlyMeters: 0, yearlyTimeMinutes: 0,
            bestDayLaps: 0, bestDayMeters: 0, bestDayDate: '-' 
        };
    }
};

export const getLeaderboard = async (): Promise<RankingItem[]> => {
    try {
        const [bookings, logs] = await Promise.all([getBookings(), getLogs()]);
        
        // Aggregate by User
        const userTotals: Record<string, { name: string, laps: number, time: number }> = {};

        logs.forEach(l => {
            if (l.laps && l.laps > 0) {
                const booking = bookings.find(b => b.id === l.bookingId);
                
                let duration = 0;
                if (l.checkInTime && l.checkOutTime) {
                    const start = new Date(l.checkInTime).getTime();
                    const end = new Date(l.checkOutTime).getTime();
                    duration = Math.max(0, Math.round((end - start) / 60000));
                }

                if (booking && booking.userName) {
                    if (!userTotals[booking.userId]) {
                        userTotals[booking.userId] = { name: booking.userName, laps: 0, time: 0 };
                    }
                    userTotals[booking.userId].laps += l.laps;
                    userTotals[booking.userId].time += duration;
                }
            }
        });

        // Convert to Array and Sort
        const ranking = Object.entries(userTotals)
            .map(([userId, data]) => ({
                userId,
                userName: data.name,
                totalLaps: data.laps,
                totalMeters: data.laps * POOL_LENGTH_METERS,
                totalTimeMinutes: data.time,
                rank: 0
            }))
            .sort((a, b) => b.totalLaps - a.totalLaps)
            .slice(0, 10); // Top 10

        // Assign Rank
        return ranking.map((item, index) => ({ ...item, rank: index + 1 }));

    } catch (e) {
        console.error("Error generating leaderboard", e);
        return [];
    }
};

// --- USER MANAGEMENT (SUPABASE) ---

// Helper to map Supabase row to User type
const mapRowToUser = (row: any): User => ({
    id: row.id.toString(),
    // MAPPING: DB uses 'fullName', App uses 'name'
    name: row.fullName || row.name || 'Sin Nombre',
    // Login fields
    username: row.username || row.email || 'user', 
    password: row.password || '', 
    // MAPPING: DB uses 'category', App uses 'role'
    role: (row.category as UserRole) || (row.role as UserRole) || UserRole.INDIVIDUAL,
    email: row.email || '',
    phone: row.phone || '',
    status: row.status || 'ACTIVO',
    lastPaymentDate: row.last_payment_date || null
});

export const getAllUsers = async (): Promise<User[]> => {
  try {
      // 1. Fetch from Supabase
      const { data, error } = await supabase
        .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
        .select('*')
        .order('fullName', { ascending: true }); // Order by fullName
      
      if (error) throw error;

      // 2. Map to User objects
      const dbUsers = data.map(mapRowToUser);

      // 3. Merge with DEMO_USERS
      // IMPORTANT: We only add demos if they DO NOT exist in DB (matching by username)
      // This prioritizes the DB ID over the DEMO ID.
      const cleanDemos = DEMO_USERS.filter(d => !dbUsers.find(db => db.username === d.username));
      
      return [...cleanDemos, ...dbUsers];
  } catch (err) {
      console.error("Error cargando usuarios de Supabase:", err);
      return DEMO_USERS;
  }
};

export const registerUser = async (user: User): Promise<void> => {
  if (DEMO_USERS.find(u => u.username === user.username)) {
      // Allow re-registering demo users to "sync" them to DB, but warn usually.
      // For this app, we just proceed to insert into DB so they get a real ID.
  }

  // Insert mapping to specific table columns
  // Note: last_payment_date is managed externally, so we do not insert it here.
  const { error } = await supabase
    .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
    .insert({
        fullName: user.name,      // Map name -> fullName
        category: user.role,      // Map role -> category
        username: user.username,
        password: user.password,
        email: user.email,
        phone: user.phone,
        status: user.status || 'ACTIVO', // Map status
        joinDate: new Date().toISOString() // Fill required text field
    });

  if (error) {
      if (error.code === '23505') throw new Error("El nombre de usuario o teléfono ya existe.");
      throw new Error(error.message);
  }
};

export const updateUser = async (updatedUser: User): Promise<void> => {
  // If it's a local demo user (id starts with 'u' and short), deny edit unless it's in DB
  if (updatedUser.id.length < 5 && DEMO_USERS.find(u => u.id === updatedUser.id)) {
      throw new Error("No se pueden editar los usuarios de demostración locales. Regístrelos en la BD primero.");
  }

  // Prepare payload dynamically
  // Note: last_payment_date is removed from payload to avoid overwriting external data
  const updatePayload: any = {
    fullName: updatedUser.name,
    category: updatedUser.role,
    username: updatedUser.username,
    email: updatedUser.email,
    phone: updatedUser.phone,
    status: updatedUser.status
  };

  if (updatedUser.password && updatedUser.password.trim().length > 0) {
      updatePayload.password = updatedUser.password;
  }

  const { error } = await supabase
    .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
    .update(updatePayload)
    .eq('id', updatedUser.id);

  if (error) throw new Error(error.message);
};

export const deleteUser = async (userId: string): Promise<void> => {
  if (userId.length < 5 && DEMO_USERS.find(u => u.id === userId)) {
      throw new Error("No se pueden eliminar los usuarios de demostración locales.");
  }

  const { error } = await supabase
    .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
    .delete()
    .eq('id', userId);

  if (error) throw new Error(error.message);
};

export const loginUser = async (username: string): Promise<User | null> => {
  // CRITICAL FIX: Check DB FIRST. 
  // If the user exists in DB, we must use that record to ensure the ID matches what getAllUsers() sees.
  try {
      const { data, error } = await supabase
        .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
        .select('*')
        .eq('username', username)
        .maybeSingle(); // maybeSingle avoids error if 0 rows

      if (data) {
          const user = mapRowToUser(data);
          localStorage.setItem(KEYS.USER, JSON.stringify(user));
          return user;
      }
  } catch (err) {
      console.error("Login DB check error:", err);
      // Fallthrough to demo users if DB fails
  }

  // Fallback to Local Demo Users
  const demoUser = DEMO_USERS.find(u => u.username === username);
  if (demoUser) {
     const user = { ...demoUser, role: demoUser.role as UserRole };
     localStorage.setItem(KEYS.USER, JSON.stringify(user));
     return user;
  }

  return null;
};

// --- SOCIAL LOGIN SYNC ---
// Used when Supabase Auth returns a user, we need to map/create them in our internal 'members' table
export const syncSocialUser = async (authUser: any): Promise<User> => {
    const email = authUser.email;
    const fullName = authUser.user_metadata?.full_name || authUser.user_metadata?.name || email.split('@')[0];
    const avatarUrl = authUser.user_metadata?.avatar_url || authUser.user_metadata?.picture;

    // 1. Check if exists in our table by email
    const { data, error } = await supabase
        .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
        .select('*')
        .eq('email', email)
        .maybeSingle();
    
    if (data) {
        // User exists, return mapped user
        const user = mapRowToUser(data);
        // Inject avatar from social session (since we might not store it in internal DB)
        if (avatarUrl) user.photoUrl = avatarUrl;
        
        localStorage.setItem(KEYS.USER, JSON.stringify(user));
        return user;
    }

    // 2. If not exists, create new INDIVIDUAL user
    const newUser: User = {
        id: `auto_${Date.now()}`, 
        username: email, 
        name: fullName,
        role: UserRole.INDIVIDUAL,
        password: '', 
        email: email,
        phone: '',
        status: 'ACTIVO',
        photoUrl: avatarUrl // Local property
    };

    // We reuse registerUser, but need to catch "Username exists" error if email=username collision happens
    try {
        await registerUser(newUser);
        
        // Fetch again to get the generated ID
        const { data: newData } = await supabase
            .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
            .select('*')
            .eq('email', email)
            .single();
        
        const createdUser = mapRowToUser(newData);
        if (avatarUrl) createdUser.photoUrl = avatarUrl;
        
        localStorage.setItem(KEYS.USER, JSON.stringify(createdUser));
        return createdUser;

    } catch (e) {
        console.error("Error syncing social user", e);
        throw e;
    }
};

export const getCurrentUser = (): User | null => {
  const data = localStorage.getItem(KEYS.USER);
  return data ? JSON.parse(data) : null;
};

export const logoutUser = async () => {
  localStorage.removeItem(KEYS.USER);
  await supabase.auth.signOut();
};

export interface AccountStatus {
  exists: boolean;
  data?: any;
  message?: string;
}

export const getAccountStatusByPhone = async (phone: string): Promise<AccountStatus> => {
  if (!phone) return { exists: false, message: "No hay teléfono registrado en su perfil." };
  
  try {
    const { data, error } = await supabase
      .from(EXTERNAL_DB_CONFIG.SUBSCRIPTION_TABLE)
      .select('*')
      .eq(EXTERNAL_DB_CONFIG.PHONE_COLUMN, phone)
      .limit(1);

    if (error) {
      return { exists: false, message: `Error DB: ${error.message}` };
    }

    if (data && data.length > 0) {
      return { exists: true, data: data[0] };
    } else {
      return { exists: false, message: "No se encontró suscripción activa." };
    }
  } catch (err: any) {
    return { exists: false, message: `Error de conexión.` };
  }
};

// --- NOTIFICATIONS ---

const mapRowToNotification = (row: any): AppNotification => ({
    id: row.id,
    userId: row.user_id,
    title: row.title,
    message: row.message,
    isRead: row.is_read,
    createdAt: row.created_at,
    type: row.type || 'INFO'
});

export const getNotifications = async (userId: string): Promise<AppNotification[]> => {
    try {
        const { data, error } = await supabase
            .from(EXTERNAL_DB_CONFIG.NOTIFICATIONS_TABLE)
            .select('*')
            .eq('user_id', userId)
            .order('created_at', { ascending: false });
        
        if (error) throw error;
        return data.map(mapRowToNotification);
    } catch (err: any) {
        if (err.message && err.message.includes('does not exist')) {
            console.warn(`[Supabase] La tabla '${EXTERNAL_DB_CONFIG.NOTIFICATIONS_TABLE}' no existe.`);
        }
        return [];
    }
};

export const markNotificationAsRead = async (notificationId: string): Promise<void> => {
    try {
        await supabase
            .from(EXTERNAL_DB_CONFIG.NOTIFICATIONS_TABLE)
            .update({ is_read: true })
            .eq('id', notificationId);
    } catch (err) {
        console.error("Failed to mark read", err);
    }
};

export const sendNotification = async (recipientId: string, title: string, message: string, type: 'INFO' | 'WARNING' | 'ALERT' = 'INFO'): Promise<void> => {
    try {
        await supabase
            .from(EXTERNAL_DB_CONFIG.NOTIFICATIONS_TABLE)
            .insert({
                user_id: recipientId,
                title,
                message,
                type,
                is_read: false
            });
    } catch (err) {
        console.error("Failed to send notification", err);
        throw err;
    }
};

export const broadcastNotification = async (title: string, message: string, targetRole?: UserRole): Promise<void> => {
    try {
        let users = await getAllUsers();
        if (targetRole) {
            users = users.filter(u => u.role === targetRole);
        }
        
        // Debug info
        console.log(`Sending notification '${title}' to ${users.length} users...`);

        const payload = users.map(u => ({
            user_id: u.id,
            title,
            message,
            type: 'INFO',
            is_read: false
        }));
        if (payload.length === 0) return;
        
        const { error } = await supabase
            .from(EXTERNAL_DB_CONFIG.NOTIFICATIONS_TABLE)
            .insert(payload);
            
        if (error) throw error;
    } catch (err) {
        console.error("Broadcast failed", err);
        throw err;
    }
};

// --- SUGGESTIONS (BUZON) ---

const mapRowToSuggestion = (row: any): Suggestion => ({
    id: row.id,
    userId: row.user_id,
    userName: row.user_name || 'Anónimo',
    date: row.created_at,
    message: row.message,
    isRead: row.is_read
});

export const getSuggestions = async (): Promise<Suggestion[]> => {
    try {
        const { data, error } = await supabase
            .from(EXTERNAL_DB_CONFIG.SUGGESTIONS_TABLE)
            .select('*')
            .order('created_at', { ascending: false });

        if (error) throw error;
        return data.map(mapRowToSuggestion);
    } catch (err: any) {
        console.warn("Error obteniendo sugerencias (tabla podría no existir)", err.message);
        return [];
    }
};

export const saveSuggestion = async (userId: string, userName: string, message: string): Promise<void> => {
    try {
        const { error } = await supabase
            .from(EXTERNAL_DB_CONFIG.SUGGESTIONS_TABLE)
            .insert({
                user_id: userId,
                user_name: userName,
                message: message,
                is_read: false
            });
        
        if (error) throw error;
    } catch (err: any) {
        console.error("Error guardando sugerencia:", err);
        throw new Error("No se pudo enviar la sugerencia.");
    }
};

export const markSuggestionRead = async (id: string, isRead: boolean): Promise<void> => {
    try {
        await supabase
            .from(EXTERNAL_DB_CONFIG.SUGGESTIONS_TABLE)
            .update({ is_read: isRead })
            .eq('id', id);
    } catch (err) {
        console.error("Error marcando sugerencia", err);
    }
};
